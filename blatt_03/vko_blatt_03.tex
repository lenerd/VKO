\documentclass[a4paper]{scrartcl}

% font/encoding packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[ngerman]{babel}
\usepackage[ngerman=ngerman-x-latest]{hyphsubst}

\usepackage{amsmath, amssymb, amsfonts, amsthm}
\usepackage{mathtools}
\usepackage{array}
\usepackage{stmaryrd}
\usepackage{marvosym}
\usepackage{subcaption}
\allowdisplaybreaks{}
\usepackage[output-decimal-marker={,}]{siunitx}
\usepackage[shortlabels]{enumitem}
\usepackage[section]{placeins}
\usepackage{float}
\usepackage{units}
\usepackage{listings}
\usepackage{pgfplots}
\pgfplotsset{compat=1.12}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usepackage{minted}

\usepackage{xcolor}
\definecolor{light-gray}{HTML}{cccccc}


\newtheorem*{proposition}{Behauptung}
\newtheorem*{definition}{Definition}
\newcommand{\gdw}{\ \Leftrightarrow\ }
\newcommand{\N}{\mathbb{N}}
\newcommand{\Oh}{\mathcal{O}}
\DeclareMathOperator{\im}{im}

\usepackage{fancyhdr}
\pagestyle{fancy}

\lstset{%
    frame=single,
    numbers=left,
    keepspaces,
    language=R,
    title=Listing: \lstname,
}

\def \blattnr {3}

\lhead{VKO -- Blatt {\blattnr}}
\rhead{Alina Bombeck, Lennart Braun, Carolin Konietzny, Tronje Krabbe}
\cfoot{\thepage}


\title{Vertiefung Kombinatorische Optimierung}
\subtitle{Blatt {\blattnr} Hausaufgaben}
\author{%
    Alina Bombeck, 6535392 (Gruppe 1) \and
    Lennart Braun, 6523742 (Gruppe 1) \and
    Carolin Konietzny, 6523939 (Gruppe 1) \and
    Tronje Krabbe, 6435002 (Gruppe 3)
}
\date{zum 25. April 2016}
\usepackage{pdfpages} 

\begin{document}
\maketitle


\begin{enumerate}[label=\bfseries \arabic*.]
\item % 1.
\begin{enumerate}
    \item % a)
        Folgender Algorithmus löst \textit{c}-HITTING SET mit einer Laufzeit von \\
        $O(f(k) \cdot p(n, m))$:
        \begin{minted}[escapeinside=||, mathescape=true]{python}
        def c_hitting_set(A, B, k):
            if B is |$\varnothing$|: return True
            if k == 0: return False
            if |$\varnothing \in$| B: return False
            pick |$B_i \in B$|
            for |$a_i \in B_i$|:
                if c_hitting_set(|$A\backslash\{a_i\}, \{B_j \in B \text{\textbar} a_i \notin B_j \}, k-1$|):
                    return True
            return False
        \end{minted}

    \item % b)

    \item % c)
        Zunächst zeigen wir, dass \textit{c}-HITTING SET in NP liegt.
        Wir nehmen als Zertifikat ein Hitting Set, also $k$ Elemente aus $A$.
        Das Zertifikat wird akzeptiert, wenn es Länge $k$ hat und wenigstens ein
        Element aus jedem $B_i$ enthält. Um dies zu prüfen, nehmen wir jedes der
        $m$ Sets und überprüfen für jedes der $n$ Elemente, ob es in den $k$ Elementen
        der Eingabe liegt. Dies hat eine Laufzeit von $O(c \cdot k \cdot m)$, oder,
        da $c \leq n$ und $k \leq n$, $O(n \cdot m^2)$. Dies ist polynomiell.
        \\
        \\
        Nun reduzieren wir VERTEX COVER auf \textit{c}-HITTING SET.
        Mit einem gegebenen ungerichteten Graphen $G$, mit $n$ Knoten und $m$ Kanten
        und einem Parameter $k$ für VERTEX COVER, definieren wir $A = V(G)$, $B_i$
        als die Menge der beiden Endknoten von Kante $e_i$, und $k$ bleibt gleich.
        Dann hat $G$ ein Vertex Cover der Größe $k$ genau dann wenn $A$ ein
        Hitting Set der Größe $k$ der Mengen $B$. Dies folgt daraus, dass
        eine Knotenmenge in $G$ genau dann ein Vertex Cover ist, wenn
        es jede der Kanten "hittet", also ein Element mit ihnen gemeinsam hat.
        \\
        \\
        Da wir lediglich die Kanten in $G$ anders anordnen müssen, benötigen
        wir nur $O(n + m)$ Laufzeit, können die oben beschriebene Umstellung also
        in höchstens polynomieller Zeit schaffen. Da \textit{c}-HITTING SET
        in NP liegt, und sich ein als NP-vollständig bekanntes Problem auf
        \textit{c}-HITTING SET reduzieren lässt, ist es ebenfalls NP-vollständig.
\end{enumerate}

\item % 2.
    Es sei $G = (V, E)$, mit einer Knotenüberdeckungsmenge $S$.

\begin{enumerate}
    \item % a)
        Jeder Knoten $v \in V$ mit einem Grad $> k$ muss in der
        Knotenüberdeckung $S$ enthalten sein, denn, wäre das nicht der Fall,
        alle (also mehr als $k$) Nachbarknoten von $v$ in $S$ enthalten sein müssen.
        Aber: $|S| < k$.

        Daraus folgt: alle Knoten $v \in D$ müssen auch in $S$ enthalten sein.
        Und: Ist nun $|D| > k$, kann es keine Knotenüberdeckung mit einer Länge
        kleiner als $k$ geben.

    \item % b)
        In Schritt 1 werden alle wegen ihres hohen Grades offensichtlich in $S$
        enthaltenen Knoten in $D$ aufgenommen. $k' = k - |D|$ bezeichnet nun die
        Anzahl der Knoten, die noch in die Knotenüberdeckung aufgenommen werden
        können. Da alle in $D$ enthaltenen Knoten in $S$ enthalten sind, können
        sie und alle ausgrenzenden Knoten aus $G$ gelöscht werden.
        Also: hat $G'$ eine Knotenüberdeckung mit höchstens $k'$ Knoten,
        so hat $G$ eine Knotenüberdeckung mit höchstens $k$ Knoten, da alle entfernten
        Kanten durch die $|D|$ Knoten berührt werden, und $|D| + k' = k$.

    \item % c)
        Aus Präsenzaufgabe 2b ist bekannt: ist $G = (V, E)$ ein Graph mit einer
        Knotenüberdeckung $S$, $|S| \leq m$ und dem Grad eines jeden Knoten
        $\leq d$, so gilt: $|V| \leq m \cdot (d+1)$.
        \\
        Für unseren Graphen $G'$ gilt: der höchste Grad ist $d = k$, da in Schritt 1
        alle überschüssigen gelöscht wurden. Und: die Knotenüberdeckung in $G'$
        hat höchstens $m = k'$ Knoten.
        \qed

    \item % d)
        Schritt 1:
        \begin{itemize}
            \item Ermitteln der Knotengrade: $O(|G|)$.
            \item Überprüfen: konstant.
            \item Löschen: maximal $O(|G|)$ (alle Knoten und Kanten in $D$)
        \end{itemize}

        Schritt 2:
        Wir müssen über alle Knoten iterieren, also noch einmal $O(|G|)$.

        Schritt 3:
        Aus dem Algorithmus in 10.1 folgt, dass dessen Laufzeit in $O(2^k n)$ liegt,
        wobei $n$ die Anzahl der Knoten ist. Zu zeigen ist, dass $n \leq k^2$.
        Da wir uns in Schritt 3 befinden, hat $G'$ weniger als $k'(k+1)$ Knoten.
        (Siehe die Bedingung am Anfang von Schritt 2).

\end{enumerate}
\end{enumerate}


\end{document}

